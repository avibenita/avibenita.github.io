<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Histogram Content</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        /* All CSS styles from the original 0HistogramPlusSite.html file */
        :root {
            --panel-bg: #484b57;
            --panel-radius: 10px;
            --panel-shadow: 0px 4px 10px rgba(0, 0, 0, 0.3);
            --header-bg: #000;
            --header-color: rgb(255,192,192);
            --panel-width: 700px;
            --panel-min-width: 280px;
            --panel-max-width: 1100px;
            --histogram-panel-width: 900px;
            --histogram-height-min: 300px;
            --histogram-height-max: 500px;
            --histogram-height-ratio: 0.4;
            --highlight-bg: rgba(255, 192, 192, 0.2);
            --highlight-text: rgb(255, 192, 192);
        }

        body {
            background-color: #282c39;
            font-family: Arial, sans-serif;
            margin: 0;
            color: white;
        }

        .panel-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 20px;
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: var(--panel-radius);
            box-shadow: var(--panel-shadow);
            flex: 0 0 auto;
            min-width: var(--panel-min-width);
            max-width: var(--panel-max-width);
            display: flex;
            flex-direction: column;
        }

        .panel-heading {
            background-color: var(--header-bg);
            color: var(--header-color);
            font-weight: bold;
            padding: 10px 15px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }

        .slider-range-labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 2px;
            font-size: clamp(0.6rem, 1.2vw, 0.8rem);
        }

        label {
            font-weight: 600;
            color: white;
            margin-right: 5px;
            font-size: clamp(0.7rem, 1.5vw, 0.9rem);
        }

        input[type="range"] {
            width: 150px;
            height: 5px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .value-display {
            font-weight: 600;
            color: white;
            min-width: 30px;
            text-align: center;
            font-size: clamp(0.7rem, 1.5vw, 0.6rem);
        }

        .tooltip {
            position: absolute;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
            z-index: 100;
        }

        .axis text {
            font-size: clamp(8px, 1.5vw, 10px);
            fill: white;
        }

        .axis path, .axis line {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        }

        .bin-range-label {
            fill: #555;
            font-size: clamp(7px, 1.2vw, 2px);
            text-anchor: middle;
        }

        .normal-line {
            fill: none;
            stroke: yellow;
            stroke-width: 2;
            stroke-dasharray: 3,3;
        }

        .bar-label {
            fill: #333;
            font-size: clamp(8px, 1.vw, 10px);
            text-anchor: middle;
            pointer-events: none;
        }

        .bar-label-percent {
            fill: white;
            font-size: clamp(10px, 1.5vw, 12px);
            text-anchor: middle;
            pointer-events: none;
        }

        #histogram {
            width: 100%;
            height: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        svg {
            width: 100%;
            height: auto;
            display: block;
        }

        .range-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            flex-wrap: wrap;
        }

        .range-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-display {
            display: flex;
            gap: 10px;
            font-size: 0.8rem;
            color: #ccc;
        }

        .reset-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .reset-button:hover {
            background-color: #2980b9;
        }

        .angle-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>

<div class="panel-row">
    <div class="panel" style="width: var(--histogram-panel-width);">
        <div class="panel-heading">
            Interactive Histogram
            <span style="margin-left: auto;">
                <i class="fas fa-expand" style="margin-left: 10px; cursor: pointer;" title="Expand"></i>
                <i class="fas fa-redo" style="margin-left: 10px; cursor: pointer;" title="Reload"></i>
                <i class="fas fa-times" style="margin-left: 10px; cursor: pointer;" title="Close"></i>
            </span>
        </div>
        <div class="controls">
            <div class="control-group">
                <label for="numBins">Number of Bins:</label>
                <span id="numBinsValue" class="value-display">5</span>
                <input type="range" id="numBins" min="1" max="20" value="5" step="1">
            </div>
            <div class="control-group">
                <label for="showNormal">Show Normal:</label>
                <input type="checkbox" id="showNormal" checked>
            </div>
        </div>
        <div id="histogram"></div>
        <div class="range-controls">
            <span>Min</span>
            <span id="leftRangeValue" class="value-display">0</span>
            <input type="range" id="leftTruncation" min="0" max="100" value="0" step="1">
            <input type="range" id="rightTruncation" min="0" max="100" value="100" step="1">
            <span id="rightRangeValue" class="value-display">100</span>
            <span>Max</span>
            <button id="resetRanges" class="reset-button">Reset</button>
            <div class="range-display">
                <span id="data-min-value">Min: 0</span>
                <span id="data-max-value">Max: 100</span>
            </div>
        </div>
    </div>
</div>

<script>
    // All of your JavaScript code for the histogram goes here.
    // This includes the `createResponsiveSVG`, `updateHistogram`, `initialize`, and `populateHistogram` functions.
    // The code from the last script block in your original file is also included below.

    function createResponsiveSVG() {
        d3.select("#histogram svg").remove();
        const histogramContainer = document.getElementById("histogram");
        if (!histogramContainer) return null;
        const containerWidth = histogramContainer.clientWidth;
        if (containerWidth <= 0) return null;
        const viewportHeight = window.innerHeight;
        const desiredHeight = Math.min(
            viewportHeight * getComputedStyle(document.documentElement).getPropertyValue('--histogram-height-ratio'),
            Math.max(
                parseInt(getComputedStyle(document.documentElement).getPropertyValue('--histogram-height-min')),
                Math.min(
                    parseInt(getComputedStyle(document.documentElement).getPropertyValue('--histogram-height-max')),
                    containerWidth * 0.4
                )
            )
        );
        const margin = {
            top: 20,
            right: Math.max(10, containerWidth * 0.02),
            bottom: 50,
            left: Math.max(10, containerWidth * 0.02)
        };
        const width = containerWidth - margin.left - margin.right;
        const height = desiredHeight - margin.top - margin.bottom;
        const svg = d3.select("#histogram")
            .append("svg")
            .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr("preserveAspectRatio", "xMidYMid meet")
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        const xAxis = svg.append("g")
            .attr("class", "axis")
            .attr("transform", `translate(0,${height})`);
        const barsGroup = svg.append("g");
        const normalCurvePath = svg.append("path")
            .attr("class", "normal-line");
        return { svg, xAxis, width, height, barsGroup, normalCurvePath };
    }

    const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

    function generateNormalData(n, mean = 0, stddev = 1) {
        return Array.from({length: n}, () => {
            const u1 = Math.random();
            const u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0 * stddev + mean;
        });
    }

    function calculateMean(data) {
        if (data.length === 0) return 0;
        return data.reduce((sum, value) => sum + value, 0) / data.length;
    }

    function calculateStdDev(data, mean) {
        if (data.length === 0) return 0;
        const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / data.length;
        return Math.sqrt(variance);
    }

    function normalPDF(x, mean, stddev) {
        if (stddev === 0) return 0;
        return (1 / (stddev * Math.sqrt(2 * Math.PI))) *
               Math.exp(-0.5 * Math.pow((x - mean) / stddev, 2));
    }

    function createHistogramBins(data, numBins) {
        if (data.length === 0) return [];
        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min;
        if (range === 0) {
            return [{
                x0: min,
                x1: min,
                length: data.length
            }];
        }
        const binWidth = range / numBins;
        const bins = [];
        for (let i = 0; i < numBins; i++) {
            const binStart = i === 0 ? min : min + i * binWidth;
            const binEnd = i === numBins - 1 ? max : min + (i + 1) * binWidth;
            let binCount = 0;
            for (let j = 0; j < data.length; j++) {
                const val = data[j];
                if ((i === 0 ? val >= binStart : val > binStart) && val <= binEnd) {
                    binCount++;
                }
            }
            bins.push({
                x0: binStart,
                x1: binEnd,
                length: binCount
            });
        }
        return bins;
    }

    let originalData = [];
    let originalMin, originalMax;
    let currentData = [];
    let svgComponents = null;
    let labelAngle = 0;
    let updateTimer = null;

    function updateHistogram(data, numBins, showNormalDist) {
        if (!data || data.length === 0) return;
        const histogramContainer = document.getElementById("histogram");
        if (!histogramContainer) return;
        const currentContainerWidth = histogramContainer.clientWidth;
        if (!svgComponents || Math.abs(currentContainerWidth - (svgComponents.lastContainerWidth || 0)) > 50) {
            svgComponents = createResponsiveSVG();
            if (svgComponents) {
                svgComponents.lastContainerWidth = currentContainerWidth;
            }
        }
        if (!svgComponents) return;
        const { svg, xAxis, width, height, barsGroup, normalCurvePath } = svgComponents;
        try {
            const mean = calculateMean(data);
            const stddev = calculateStdDev(data, mean);
            const minValue = Math.min(...data);
            const maxValue = Math.max(...data);
            const x = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range([0, width]);
            const histogram = createHistogramBins(data, numBins);
            if (histogram.length === 0) return;
            const y = d3.scaleLinear()
                .domain([0, d3.max(histogram, d => d.length) || 1])
                .range([height, 0]);
            xAxis.selectAll("*").remove();
            xAxis.append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", width)
                .attr("y2", 0)
                .attr("stroke", "#ddd");
            histogram.forEach(bin => {
                xAxis.append("line")
                    .attr("x1", x(bin.x0))
                    .attr("y1", 0)
                    .attr("x2", x(bin.x0))
                    .attr("y2", 5)
                    .attr("stroke", "#ddd");
            });
            xAxis.append("line")
                .attr("x1", x(histogram[histogram.length-1].x1))
                .attr("y1", 0)
                .attr("x2", x(histogram[histogram.length-1].x1))
                .attr("y2", 5)
                .attr("stroke", "#ddd");
            histogram.forEach(bin => {
                const midpoint = x(bin.x0) + (x(bin.x1) - x(bin.x0)) / 2;
                let labelAngle = 0;
                const yPos = labelAngle === 0 ? 20 : 10;
                xAxis.append("text")
                    .attr("class", "bin-range-label")
                    .attr("x", midpoint)
                    .attr("y", yPos)
                    .attr("transform", `rotate(${labelAngle}, ${midpoint}, ${yPos})`)
                    .style("text-anchor", labelAngle === 0 ? "middle" : "start")
                    .text(`${bin.x0.toFixed(1)}-${bin.x1.toFixed(1)}`);
            });
            const colorScale = d3.scaleLinear()
                .domain([0, d3.max(histogram, d => d.length) || 1])
                .range(["#74b9ff", "#0984e3"]);
            barsGroup.selectAll("*").remove();
            const bars = barsGroup.selectAll(".bar")
                .data(histogram)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.x0) + 1)
                .attr("y", d => y(d.length))
                .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 1))
                .attr("height", d => height - y(d.length))
                .attr("fill", d => colorScale(d.length))
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    let rangeText = "";
                    if (d === histogram[0]) {
                        rangeText = `Range: ${d.x0.toFixed(2)} ≤ x ≤ ${d.x1.toFixed(2)}`;
                    } else {
                        rangeText = `Range: ${d.x0.toFixed(2)} < x ≤ ${d.x1.toFixed(2)}`;
                    }
                    tooltip.html(`${rangeText}<br>Count: ${d.length}<br>Percentage: ${(d.length / data.length * 100).toFixed(1)}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    d3.select(this)
                        .attr("fill", "#e74c3c");
                })
                .on("mouseout", function(event, d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                    d3.select(this)
                        .attr("fill", colorScale(d.length));
                });
            const containerWidth = document.getElementById("histogram").clientWidth;
            if (containerWidth > 500) {
                barsGroup.selectAll(".bar-label-percent")
                    .data(histogram)
                    .enter()
                    .append("text")
                    .attr("class", "bar-label-percent")
                    .attr("x", d => x(d.x0) + (x(d.x1) - x(d.x0)) / 2)
                    .attr("y", d => y(d.length) - 3)
                    .text(d => (d.length / data.length * 100).toFixed(0) + '%')
                    .filter(d => height - y(d.length) > 20);
            }
            if (showNormalDist && stddev > 0) {
                const curvePoints = [];
                const range = maxValue - minValue;
                if (range === 0) {
                    normalCurvePath.style("opacity", 0);
                    return;
                }
                const step = range / 100;
                const curveMin = Math.max(minValue - range * 0.1, mean - 4 * stddev);
                const curveMax = Math.min(maxValue + range * 0.1, mean + 4 * stddev);
                for (let i = curveMin; i <= curveMax; i += step) {
                    curvePoints.push({
                        x: i,
                        y: normalPDF(i, mean, stddev)
                    });
                }
                const maxPDF = d3.max(curvePoints, d => d.y) || 0;
                const maxHistHeight = d3.max(histogram, d => d.length) || 1;
                const scaleFactor = maxHistHeight / (maxPDF || 1);
                const line = d3.line()
                    .x(d => x(d.x))
                    .y(d => y(d.y * scaleFactor))
                    .curve(d3.curveBasis);
                normalCurvePath
                    .datum(curvePoints)
                    .attr("d", line)
                    .style("opacity", 1);
            } else {
                normalCurvePath.style("opacity", 0);
            }
        } catch (err) {
            console.error("Error updating histogram:", err);
        }
    }

    function percentToValue(percent) {
        return originalMin + (originalMax - originalMin) * (percent / 100);
    }

    function updateTruncationControls() {
        clearTimeout(updateTimer);
        updateTimer = setTimeout(() => {
            try {
                const leftPercent = parseFloat(d3.select("#leftTruncation").property("value"));
                const rightPercent = parseFloat(d3.select("#rightTruncation").property("value"));
                const leftValue = percentToValue(leftPercent);
                const rightValue = percentToValue(rightPercent);
                d3.select("#leftRangeValue").text(leftValue.toFixed(2));
                d3.select("#rightRangeValue").text(rightValue.toFixed(2));
                currentData = originalData.filter(d => d >= leftValue && d <= rightValue);
                if (currentData.length === 0) {
                    currentData = [originalData[0]];
                }
                updateHistogram(
                    currentData,
                    parseInt(d3.select("#numBins").property("value")),
                    d3.select("#showNormal").property("checked")
                );
            } catch (err) {
                console.error("Error in truncation control update:", err);
            }
        }, 50);
    }

    function initialize() {
        try {
            const histogramContainer = document.getElementById("histogram");
            if (!histogramContainer || histogramContainer.clientWidth <= 0) {
                // If container is not yet ready, wait a bit and try again
                setTimeout(initialize, 100);
                return;
            }

            originalData = generateNormalData(1000, 50, 15);
            currentData = [...originalData];
            originalMin = Math.min(...originalData);
            originalMax = Math.max(...originalData);
            d3.select("#data-min-value").text(`Min: ${originalMin.toFixed(2)}`);
            d3.select("#data-max-value").text(`Max: ${originalMax.toFixed(2)}`);
            d3.select("#leftRangeValue").text(originalMin.toFixed(2));
            d3.select("#rightRangeValue").text(originalMax.toFixed(2));
            d3.select("#numBins").on("input", function() {
                try {
                    const value = +this.value;
                    d3.select("#numBinsValue").text(value);
                    clearTimeout(updateTimer);
                    updateTimer = setTimeout(() => {
                        updateHistogram(currentData, value, d3.select("#showNormal").property("checked"));
                    }, 50);
                } catch (err) {
                    console.error("Error in numBins handler:", err);
                }
            });
            d3.select("#showNormal").on("change", function() {
                try {
                    updateHistogram(
                        currentData,
                        +d3.select("#numBins").property("value"),
                        this.checked
                    );
                } catch (err) {
                    console.error("Error in showNormal handler:", err);
                }
            });
            d3.select("#leftTruncation").on("input", function() {
                try {
                    const leftPercent = +this.value;
                    const rightPercent = +d3.select("#rightTruncation").property("value");
                    if (leftPercent >= rightPercent - 1) {
                        d3.select("#rightTruncation").property("value", Math.min(100, leftPercent + 1));
                    }
                    updateTruncationControls();
                } catch (err) {
                    console.error("Error in leftTruncation handler:", err);
                }
            });
            d3.select("#rightTruncation").on("input", function() {
                try {
                    const rightPercent = +this.value;
                    const leftPercent = +d3.select("#leftTruncation").property("value");
                    if (rightPercent <= leftPercent + 1) {
                        d3.select("#leftTruncation").property("value", Math.max(0, rightPercent - 1));
                    }
                    updateTruncationControls();
                } catch (err) {
                    console.error("Error in rightTruncation handler:", err);
                }
            });
            d3.select("#resetRanges").on("click", function() {
                try {
                    d3.select("#leftTruncation").property("value", 0);
                    d3.select("#rightTruncation").property("value", 100);
                    currentData = [...originalData];
                    d3.select("#leftRangeValue").text(originalMin.toFixed(2));
                    d3.select("#rightRangeValue").text(originalMax.toFixed(2));
                    updateHistogram(
                        currentData,
                        +d3.select("#numBins").property("value"),
                        d3.select("#showNormal").property("checked")
                    );
                } catch (err) {
                    console.error("Error in reset handler:", err);
                }
            });
            const initialBins = +d3.select("#numBins").property("value");
            d3.select("#numBinsValue").text(initialBins);
            updateHistogram(currentData, initialBins, d3.select("#showNormal").property("checked"));
            // Resize handler moved to bottom of file to avoid duplication
        } catch (err) {
            console.error("Error in initialization:", err);
        }
    }

    function populateHistogram(jsonString, numBins) {
        console.log("Received JSON:", jsonString);
        try {
            const jsonData = JSON.parse(jsonString);
            if (Array.isArray(jsonData.values)) {
                originalData = jsonData.values;
                currentData = [...originalData];
                originalMin = Math.min(...originalData);
                originalMax = Math.max(...originalData);
                d3.select("#data-min-value").text(`Min: ${originalMin.toFixed(2)}`);
                d3.select("#data-max-value").text(`Max: ${originalMax.toFixed(2)}`);
                d3.select("#leftRangeValue").text(originalMin.toFixed(2));
                d3.select("#rightRangeValue").text(originalMax.toFixed(2));
                d3.select("#leftTruncation").property("value", 0);
                d3.select("#rightTruncation").property("value", 100);
                if (window.updateHeaderTitle) {
                    window.updateHeaderTitle(jsonData.title);
                }
                const showNormalDist = d3.select("#showNormal").property("checked");
                updateHistogram(currentData, numBins, showNormalDist);
                return true;
            } else {
                console.error("Invalid JSON format: 'values' array not found");
                return false;
            }
        } catch (e) {
            console.error("Error parsing JSON:", e);
            return false;
        }
    }

    window.populateHistogram = populateHistogram;

    let decimalPlaces = 2;
    function updateDecimalAll(val) {
        decimalPlaces = parseInt(val);
        syncSummaryStats();
    }
    function syncSummaryStats() {
        if (!currentData || currentData.length === 0) return;
        const mean = calculateMean(currentData);
        const stddev = calculateStdDev(currentData, mean);
        const median = calculateMedian(currentData);
        const variance = stddev ** 2;
        const sorted = [...currentData].sort((a, b) => a - b);
        const n = sorted.length;
        const min = sorted[0];
        const max = sorted[n - 1];
        const q25 = sorted[Math.floor(n * 0.25)];
        const q75 = sorted[Math.floor(n * 0.75)];
        const range = max - min;
        const cv = mean !== 0 ? (stddev / mean * 100) : 0;
        const skewness = n > 2 ? (
            n / ((n - 1) * (n - 2)) *
            sorted.reduce((acc, val) => acc + Math.pow((val - mean) / stddev, 3), 0)
        ) : 0;
        const kurtosis = n > 3 ? (
            (n*(n+1))/((n-1)*(n-2)*(n-3)) *
            sorted.reduce((acc, val) => acc + Math.pow((val - mean) / stddev, 4), 0)
            - (3*(n-1)**2)/((n-2)*(n-3))
        ) : 0;
        document.getElementById('stat-n').textContent = n;
        document.getElementById('stat-mean').textContent = mean.toFixed(decimalPlaces);
        document.getElementById('stat-stddev').textContent = stddev.toFixed(decimalPlaces);
        document.getElementById('stat-median').textContent = median.toFixed(decimalPlaces);
        document.getElementById('stat-range').textContent = range.toFixed(decimalPlaces);
        document.getElementById('stat-variance').textContent = variance.toFixed(decimalPlaces);
        document.getElementById('stat-min').textContent = min.toFixed(decimalPlaces);
        document.getElementById('stat-max').textContent = max.toFixed(decimalPlaces);
        document.getElementById('stat-q25').textContent = q25.toFixed(decimalPlaces);
        document.getElementById('stat-q75').textContent = q75.toFixed(decimalPlaces);
        document.getElementById('stat-cv').textContent = cv.toFixed(decimalPlaces);
        document.getElementById('stat-kurtosis').textContent = kurtosis.toFixed(decimalPlaces);
        document.getElementById('stat-skewness').textContent = skewness.toFixed(decimalPlaces);
    }

    function calculateMedian(data) {
        const sorted = [...data].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    window.addEventListener('DOMContentLoaded', function () {
        if (typeof updateHistogram === 'function') {
            const originalUpdateHistogram = updateHistogram;
            updateHistogram = function (data, numBins, showNormalDist) {
                originalUpdateHistogram(data, numBins, showNormalDist);
                syncSummaryStats();
            };
        }
    });

    syncSummaryStats();
    initialize();

    // Enhanced resize handler for iframe support
    window.addEventListener('resize', function() {
        try {
            clearTimeout(updateTimer);
            updateTimer = setTimeout(() => {
                const histogramContainer = document.getElementById("histogram");
                if (histogramContainer && histogramContainer.clientWidth > 0) {
                    svgComponents = null; // Force SVG recreation on resize
                    updateHistogram(
                        currentData,
                        +d3.select("#numBins").property("value"),
                        d3.select("#showNormal").property("checked")
                    );
                }
            }, 200); // Longer delay for iframe context
        } catch (err) {
            console.error("Error in resize handler:", err);
        }
    });

    // Also listen for visibility changes (when iframe becomes visible in modal)
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            setTimeout(() => {
                const histogramContainer = document.getElementById("histogram");
                if (histogramContainer && histogramContainer.clientWidth > 0 && currentData.length > 0) {
                    svgComponents = null;
                    updateHistogram(
                        currentData,
                        +d3.select("#numBins").property("value"),
                        d3.select("#showNormal").property("checked")
                    );
                }
            }, 100);
        }
    });
</script>
</body>
</html>
