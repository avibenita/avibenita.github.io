<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Histogram</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

  <style>
    :root {
      --surface-0: #0c1624;
      --surface-1: #1a1f2e;
      --surface-2: #242938;
      --border: #2d3748;
      --accent-1: rgb(255,165,120);
      --accent-2: rgb(120,200,255);
      --text-primary: #ffffff;
      --text-secondary: rgba(255,255,255,0.8);
      --text-muted: rgba(255,255,255,0.6);
      --panel-bg: var(--surface-1);
      --panel-radius: 10px;
      --panel-shadow: 0px 4px 20px rgba(0, 0, 0, 0.4);
      --header-bg: #000;
      --header-color: var(--accent-1);
    }

    body {
      background-color: var(--surface-0);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      color: var(--text-primary);
    }

    .panel {
      margin: 15px;
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: var(--panel-radius);
      box-shadow: var(--panel-shadow);
    }

    .panel-heading {
      padding: 12px 20px;
      background: var(--header-bg);
      color: var(--header-color);
      border-radius: var(--panel-radius) var(--panel-radius) 0 0;
      border-bottom: 1px solid var(--border);
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .panel-body {
      padding: 15px;
    }

    table {
      width: 100%;
      text-align: center;
      background: var(--surface-2);
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--border);
      margin-bottom: 12px;
      border-collapse: collapse;
    }

    th {
      padding: 8px 12px;
      font-weight: 600;
      font-size: 14px;
      background: rgba(255, 165, 120, 0.3);
      color: var(--text-primary);
    }

    td {
      padding: 12px 15px;
      font-size: 16px;
      font-weight: 700;
      background: rgba(255,165,120,0.1);
      color: var(--accent-1);
    }

    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
      font-size: 14px;
      align-items: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .value-display {
      min-width: 25px;
      font-size: 14px;
      font-weight: 600;
    }

    .range-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 5px;
      font-size: 14px;
    }

    .range-display {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .reset-button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
      margin-left: 10px;
    }

    .reset-button:hover {
      background-color: #2980b9;
    }

    .tooltip {
      position: absolute;
      padding: 8px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 4px;
      pointer-events: none;
      font-size: 14px;
      z-index: 100;
    }

    .axis text {
      font-size: 10px;
      fill: white;
    }

    .axis path, .axis line {
      fill: none;
      stroke: #ddd;
      shape-rendering: crispEdges;
    }

    .bin-range-label {
      fill: #555;
      font-size: 8px;
      text-anchor: middle;
    }

    .normal-line {
      fill: none;
      stroke: yellow;
      stroke-width: 2;
      stroke-dasharray: 3,3;
    }

    .bar-label-percent {
      fill: white;
      font-size: 12px;
      text-anchor: middle;
      pointer-events: none;
    }

    #histogram {
      width: 100%;
      height: auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    svg {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Centered container */
    .centered-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 1200px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div class="centered-container">
    <!-- Descriptive Statistics Panel -->
    <div class="panel" id="statistics-panel">
      <div class="panel-heading">
        <span>Descriptive Statistics</span>
        <select onchange="updateDecimalAll(this.value)" style="padding: 4px 8px; font-size: 12px; background: var(--surface-2); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
        </select>
      </div>
      <div class="panel-body">
        <!-- First Table -->
        <table>
          <tr>
            <th>Count</th>
            <th>Average</th>
            <th>Std Dev</th>
            <th>Variance</th>
            <th>Kurtosis</th>
            <th>Skewness</th>
          </tr>
          <tr>
            <td id="stat-n">--</td>
            <td id="stat-mean">--</td>
            <td id="stat-stddev">--</td>
            <td id="stat-variance">--</td>
            <td id="stat-kurtosis">--</td>
            <td id="stat-skewness">--</td>
          </tr>
        </table>

        <!-- Second Table -->
        <table>
          <tr>
            <th>Range</th>
            <th>Minimum</th>
            <th>Q25</th>
            <th style="background: rgba(255, 165, 120, 0.3);">Median</th>
            <th>Q75</th>
            <th>Maximum</th>
          </tr>
          <tr>
            <td id="stat-range" style="color: var(--text-primary); font-weight: 500;">--</td>
            <td id="stat-min" style="color: var(--text-primary); font-weight: 500;">--</td>
            <td id="stat-q25" style="color: var(--text-primary); font-weight: 500;">--</td>
            <td id="stat-median">--</td>
            <td id="stat-q75" style="color: var(--text-primary); font-weight: 500;">--</td>
            <td id="stat-max" style="color: var(--text-primary); font-weight: 500;">--</td>
          </tr>
        </table>
      </div>
    </div>

    <!-- Interactive Histogram Panel -->
    <div class="panel" id="histogram-panel" style="min-height: 500px;">
      <div class="panel-heading">
        <span>Interactive Histogram</span>
        <div>
          <i class="fas fa-redo" style="margin-left: 15px; cursor: pointer; font-size: 14px;" title="Generate New Data" onclick="loadSimulatedData()"></i>
        </div>
      </div>

      <div class="panel-body" style="display: flex; flex-direction: column; min-height: 450px;">
        <!-- Controls -->
        <div class="controls">
          <div class="control-group">
            <label for="numBins" style="font-weight: 500;">Bins:</label>
            <span id="numBinsValue" class="value-display">5</span>
            <input type="range" id="numBins" min="1" max="20" value="5" step="1" style="width: 100px;">
          </div>
          <div class="control-group">
            <label for="showNormal" style="font-weight: 500;">Normal:</label>
            <input type="checkbox" id="showNormal" checked style="width: 18px; height: 18px;">
          </div>
        </div>

        <!-- Histogram chart -->
        <div id="histogram" style="flex: 1; min-height: 300px; margin: 10px 0 5px 0;"></div>

        <!-- Range controls -->
        <div class="range-controls">
          <span style="font-weight: 500;">Min</span>
          <span id="leftRangeValue" class="value-display" style="min-width: 50px; font-weight: 600;">0</span>
          <input type="range" id="leftTruncation" min="0" max="100" value="0" step="1" style="flex: 1; height: 8px;">
          <input type="range" id="rightTruncation" min="0" max="100" value="100" step="1" style="flex: 1; height: 8px;">
          <span id="rightRangeValue" class="value-display" style="min-width: 50px; font-weight: 600;">100</span>
          <span style="font-weight: 500;">Max</span>
          <button id="resetRanges" class="reset-button">Reset</button>
        </div>
          
        <!-- Data range display -->
        <div class="range-display">
          <span id="data-min-value">Min: 0</span>
          <span id="data-max-value">Max: 100</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let svgComponents = null;
    let currentData = [];
    let originalData = [];
    let originalMin = 0;
    let originalMax = 100;
    let updateTimer = null;

    // Create responsive SVG
    function createResponsiveSVG() {
      d3.select("#histogram svg").remove();
      
      const histogramContainer = document.getElementById("histogram");
      if (!histogramContainer) return null;
      
      const containerWidth = histogramContainer.clientWidth;
      if (containerWidth <= 0) return null;
      
      const desiredHeight = 300;
      const margin = {top: 20, right: 20, bottom: 50, left: 20};
      const width = containerWidth - margin.left - margin.right;
      const height = desiredHeight - margin.top - margin.bottom;
      
      const svg = d3.select("#histogram")
        .append("svg")
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
      
      const xAxis = svg.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`);
      const barsGroup = svg.append("g");
      const normalCurvePath = svg.append("path").attr("class", "normal-line");
      
      return { svg, xAxis, width, height, barsGroup, normalCurvePath };
    }

    // Create tooltip
    const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

    // Generate normal distribution data
    function generateNormalData(n, mean = 0, stddev = 1) {
      return Array.from({length: n}, () => {
        const u1 = Math.random();
        const u2 = Math.random();
        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        return z0 * stddev + mean;
      });
    }

    // Generate right-skewed data
    function generateSkewedData(n, baseMean, skewFactor) {
      return Array.from({length: n}, () => {
        const u = Math.random();
        const exponential = -Math.log(1 - u) / (1 / skewFactor);
        return baseMean + exponential * (baseMean * 0.3);
      });
    }

    // Calculate statistics
    function calculateMean(data) {
      if (data.length === 0) return 0;
      return data.reduce((sum, value) => sum + value, 0) / data.length;
    }

    function calculateStdDev(data, mean) {
      if (data.length === 0) return 0;
      const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / data.length;
      return Math.sqrt(variance);
    }

    function calculatePercentile(sortedArray, percentile) {
      const index = (percentile / 100) * (sortedArray.length - 1);
      const lower = Math.floor(index);
      const upper = Math.ceil(index);
      const weight = index % 1;
      
      if (upper >= sortedArray.length) return sortedArray[sortedArray.length - 1];
      return sortedArray[lower] * (1 - weight) + sortedArray[upper] * weight;
    }

    function calculateSkewness(data, mean, stddev) {
      if (data.length === 0 || stddev === 0) return 0;
      const n = data.length;
      const sum = data.reduce((acc, val) => acc + Math.pow((val - mean) / stddev, 3), 0);
      return (n / ((n - 1) * (n - 2))) * sum;
    }

    function calculateKurtosis(data, mean, stddev) {
      if (data.length === 0 || stddev === 0) return 0;
      const n = data.length;
      const sum = data.reduce((acc, val) => acc + Math.pow((val - mean) / stddev, 4), 0);
      return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sum - (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));
    }

    // Normal PDF
    function normalPDF(x, mean, stddev) {
      if (stddev === 0) return 0;
      return (1 / (stddev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mean) / stddev, 2));
    }

    // Create histogram bins
    function createHistogramBins(data, numBins) {
      if (data.length === 0) return [];
      
      const min = Math.min(...data);
      const max = Math.max(...data);
      const range = max - min;
      
      if (range === 0) {
        return [{x0: min, x1: min, length: data.length}];
      }
      
      const binWidth = range / numBins;
      const bins = [];
      
      for (let i = 0; i < numBins; i++) {
        const binStart = min + i * binWidth;
        const binEnd = i === numBins - 1 ? max : min + (i + 1) * binWidth;
        
        const binData = data.filter(d => {
          if (i === 0) return d >= binStart && d <= binEnd;
          return d > binStart && d <= binEnd;
        });
        
        bins.push({
          x0: binStart,
          x1: binEnd,
          length: binData.length
        });
      }
      
      return bins;
    }

    // Update histogram
    function updateHistogram(data, numBins, showNormalDist) {
      if (!data || data.length === 0) return;
      
      if (!svgComponents) {
        svgComponents = createResponsiveSVG();
      }
      if (!svgComponents) return;
      
      const { svg, xAxis, width, height, barsGroup, normalCurvePath } = svgComponents;
      
      try {
        const mean = calculateMean(data);
        const stddev = calculateStdDev(data, mean);
        const minValue = Math.min(...data);
        const maxValue = Math.max(...data);
        
        const x = d3.scaleLinear().domain([minValue, maxValue]).range([0, width]);
        const histogram = createHistogramBins(data, numBins);
        
        if (histogram.length === 0) return;
        
        const y = d3.scaleLinear().domain([0, d3.max(histogram, d => d.length) || 1]).range([height, 0]);
        
        // Update x-axis
        xAxis.selectAll("*").remove();
        xAxis.append("line").attr("x1", 0).attr("y1", 0).attr("x2", width).attr("y2", 0).attr("stroke", "#ddd");
        
        histogram.forEach(bin => {
          xAxis.append("line").attr("x1", x(bin.x0)).attr("y1", 0).attr("x2", x(bin.x0)).attr("y2", 5).attr("stroke", "#ddd");
        });
        xAxis.append("line").attr("x1", x(histogram[histogram.length-1].x1)).attr("y1", 0).attr("x2", x(histogram[histogram.length-1].x1)).attr("y2", 5).attr("stroke", "#ddd");
        
        // Add labels
        histogram.forEach(bin => {
          const midpoint = x(bin.x0) + (x(bin.x1) - x(bin.x0)) / 2;
          xAxis.append("text").attr("class", "bin-range-label").attr("x", midpoint).attr("y", 20).attr("text-anchor", "middle")
            .text(`${bin.x0.toFixed(1)}-${bin.x1.toFixed(1)}`);
        });
        
        // Color scale
        const colorScale = d3.scaleLinear().domain([0, d3.max(histogram, d => d.length) || 1])
          .range(["rgba(255, 165, 120, 0.3)", "rgba(255, 165, 120, 0.6)"]);
        
        // Create bars
        barsGroup.selectAll("*").remove();
        const bars = barsGroup.selectAll(".bar").data(histogram).enter().append("rect").attr("class", "bar")
          .attr("x", d => x(d.x0) + 1).attr("y", d => y(d.length)).attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 1))
          .attr("height", d => height - y(d.length)).attr("fill", d => colorScale(d.length))
          .on("mouseover", function(event, d) {
            tooltip.transition().duration(200).style("opacity", .9);
            const rangeText = d === histogram[0] ? `Range: ${d.x0.toFixed(2)} ≤ x ≤ ${d.x1.toFixed(2)}` : `Range: ${d.x0.toFixed(2)} < x ≤ ${d.x1.toFixed(2)}`;
            tooltip.html(`${rangeText}<br>Count: ${d.length}<br>Percentage: ${(d.length / data.length * 100).toFixed(1)}%`)
              .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 28) + "px");
            d3.select(this).attr("fill", "rgba(120, 200, 255, 0.5)");
          })
          .on("mouseout", function(event, d) {
            tooltip.transition().duration(500).style("opacity", 0);
            d3.select(this).attr("fill", colorScale(d.length));
          });
        
        // Add percentage labels
        const containerWidth = document.getElementById("histogram").clientWidth;
        if (containerWidth > 500) {
          barsGroup.selectAll(".bar-label-percent").data(histogram).enter().append("text").attr("class", "bar-label-percent")
            .attr("x", d => x(d.x0) + (x(d.x1) - x(d.x0)) / 2).attr("y", d => y(d.length) - 3)
            .text(d => (d.length / data.length * 100).toFixed(0) + '%')
            .filter(d => height - y(d.length) > 20);
        }
        
        // Draw normal curve
        if (showNormalDist && stddev > 0) {
          const curvePoints = [];
          const range = maxValue - minValue;
          
          if (range > 0) {
            const step = range / 100;
            const curveMin = Math.max(minValue - range * 0.1, mean - 4 * stddev);
            const curveMax = Math.min(maxValue + range * 0.1, mean + 4 * stddev);
            
            for (let i = curveMin; i <= curveMax; i += step) {
              curvePoints.push({x: i, y: normalPDF(i, mean, stddev)});
            }
            
            const maxPDF = d3.max(curvePoints, d => d.y) || 0;
            const maxHistHeight = d3.max(histogram, d => d.length) || 1;
            const scaleFactor = maxHistHeight / (maxPDF || 1);
            
            const line = d3.line().x(d => x(d.x)).y(d => y(d.y * scaleFactor)).curve(d3.curveBasis);
            normalCurvePath.datum(curvePoints).attr("d", line).style("opacity", 1);
          }
        } else {
          normalCurvePath.style("opacity", 0);
        }
        
        // Update statistics
        populateStatistics(data);
      } catch (err) {
        console.error("Error updating histogram:", err);
      }
    }

    // Populate statistics table
    function populateStatistics(data) {
      if (!data || data.length === 0) return;
      
      try {
        const n = data.length;
        const mean = calculateMean(data);
        const stddev = calculateStdDev(data, mean);
        const variance = stddev * stddev;
        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min;
        
        const sortedData = [...data].sort((a, b) => a - b);
        const q1 = calculatePercentile(sortedData, 25);
        const median = calculatePercentile(sortedData, 50);
        const q3 = calculatePercentile(sortedData, 75);
        
        const skewness = calculateSkewness(data, mean, stddev);
        const kurtosis = calculateKurtosis(data, mean, stddev);
        
        const decimals = parseInt(document.querySelector('select[onchange*="updateDecimalAll"]').value) || 2;
        
        const updateStat = (id, value, decimals = 2) => {
          const element = document.getElementById(id);
          if (element) {
            element.textContent = typeof value === 'number' ? value.toFixed(decimals) : value.toString();
          }
        };
        
        updateStat('stat-n', n, 0);
        updateStat('stat-mean', mean, decimals);
        updateStat('stat-stddev', stddev, decimals);
        updateStat('stat-variance', variance, decimals);
        updateStat('stat-kurtosis', kurtosis, decimals);
        updateStat('stat-skewness', skewness, decimals);
        updateStat('stat-range', range, decimals);
        updateStat('stat-min', min, decimals);
        updateStat('stat-q25', q1, decimals);
        updateStat('stat-median', median, decimals);
        updateStat('stat-q75', q3, decimals);
        updateStat('stat-max', max, decimals);
      } catch (err) {
        console.error("Error calculating statistics:", err);
      }
    }

    // Convert percentage to value
    function percentToValue(percent) {
      return originalMin + (originalMax - originalMin) * (percent / 100);
    }

    // Update truncation controls
    function updateTruncationControls() {
      clearTimeout(updateTimer);
      updateTimer = setTimeout(() => {
        try {
          const leftPercent = parseFloat(d3.select("#leftTruncation").property("value"));
          const rightPercent = parseFloat(d3.select("#rightTruncation").property("value"));
          
          const leftValue = percentToValue(leftPercent);
          const rightValue = percentToValue(rightPercent);
          
          d3.select("#leftRangeValue").text(leftValue.toFixed(2));
          d3.select("#rightRangeValue").text(rightValue.toFixed(2));
          
          currentData = originalData.filter(d => d >= leftValue && d <= rightValue);
          
          if (currentData.length === 0) {
            currentData = [originalData[0]];
          }
          
          updateHistogram(currentData, parseInt(d3.select("#numBins").property("value")), d3.select("#showNormal").property("checked"));
        } catch (err) {
          console.error("Error in truncation control update:", err);
        }
      }, 50);
    }

    // Load simulated data
    function loadSimulatedData() {
      try {
        const dataSize = 500;
        const mean = Math.random() * 60 + 20;
        const stddev = Math.random() * 15 + 5;
        
        let newData;
        const distributionType = Math.floor(Math.random() * 3);
        
        switch (distributionType) {
          case 0:
            newData = generateNormalData(dataSize, mean, stddev);
            break;
          case 1:
            newData = generateSkewedData(dataSize, mean, 2);
            break;
          default:
            newData = generateNormalData(dataSize, mean, stddev);
            break;
        }
        
        originalData = [...newData];
        currentData = [...newData];
        originalMin = Math.min(...originalData);
        originalMax = Math.max(...originalData);
        
        d3.select("#data-min-value").text(`Min: ${originalMin.toFixed(2)}`);
        d3.select("#data-max-value").text(`Max: ${originalMax.toFixed(2)}`);
        
        d3.select("#leftTruncation").property("value", 0);
        d3.select("#rightTruncation").property("value", 100);
        d3.select("#leftRangeValue").text(originalMin.toFixed(2));
        d3.select("#rightRangeValue").text(originalMax.toFixed(2));
        
        updateHistogram(currentData, +d3.select("#numBins").property("value"), d3.select("#showNormal").property("checked"));
      } catch (err) {
        console.error("Error loading simulated data:", err);
      }
    }

    // Update decimal places
    function updateDecimalAll(decimals) {
      if (currentData.length > 0) {
        populateStatistics(currentData);
      }
    }

    // Initialize
    function initialize() {
      try {
        originalData = [];
        currentData = [];
        originalMin = 0;
        originalMax = 100;
        
        d3.select("#data-min-value").text("Min: --");
        d3.select("#data-max-value").text("Max: --");
        d3.select("#leftRangeValue").text("0");
        d3.select("#rightRangeValue").text("100");
        
        // Event listeners
        d3.select("#numBins").on("input", function() {
          const value = +this.value;
          d3.select("#numBinsValue").text(value);
          clearTimeout(updateTimer);
          updateTimer = setTimeout(() => {
            updateHistogram(currentData, value, d3.select("#showNormal").property("checked"));
          }, 50);
        });
        
        d3.select("#showNormal").on("change", function() {
          updateHistogram(currentData, +d3.select("#numBins").property("value"), this.checked);
        });
        
        d3.select("#leftTruncation").on("input", function() {
          const leftPercent = +this.value;
          const rightPercent = +d3.select("#rightTruncation").property("value");
          if (leftPercent >= rightPercent - 1) {
            d3.select("#rightTruncation").property("value", Math.min(100, leftPercent + 1));
          }
          updateTruncationControls();
        });
        
        d3.select("#rightTruncation").on("input", function() {
          const rightPercent = +this.value;
          const leftPercent = +d3.select("#leftTruncation").property("value");
          if (rightPercent <= leftPercent + 1) {
            d3.select("#leftTruncation").property("value", Math.max(0, rightPercent - 1));
          }
          updateTruncationControls();
        });
        
        d3.select("#resetRanges").on("click", function() {
          d3.select("#leftTruncation").property("value", 0);
          d3.select("#rightTruncation").property("value", 100);
          currentData = [...originalData];
          d3.select("#leftRangeValue").text(originalMin.toFixed(2));
          d3.select("#rightRangeValue").text(originalMax.toFixed(2));
          updateHistogram(currentData, +d3.select("#numBins").property("value"), d3.select("#showNormal").property("checked"));
        });
        
        const initialBins = +d3.select("#numBins").property("value");
        d3.select("#numBinsValue").text(initialBins);
        
        // Load data after initialization
        setTimeout(() => {
          loadSimulatedData();
        }, 500);
        
        // Resize listener
        window.addEventListener('resize', function() {
          clearTimeout(updateTimer);
          updateTimer = setTimeout(() => {
            svgComponents = null;
            updateHistogram(currentData, +d3.select("#numBins").property("value"), d3.select("#showNormal").property("checked"));
          }, 150);
        });
      } catch (err) {
        console.error("Error in initialization:", err);
      }
    }

    // Initialize when page loads
    initialize();
  </script>
</body>
</html>
